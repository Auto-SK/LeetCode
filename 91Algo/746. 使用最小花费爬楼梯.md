## 方法一：动态规划

### 算法流程

- 定义 dp 数组，dp[i] 定义为登完 i 阶台阶所需最小花费（子问题）
- 思考：登完当前第 i 阶台阶所需花费是第 i 阶台阶消耗体力 + (dp[i-1] or dp[i - 2])，由于所求为最小，故可得状态转移方程为：

<center>dp[i] = min(dp[i - 1], dp[i- 2]) + i′cost</center>

- 注意初始化第 1 阶和第 2 阶的情况

### 复杂度分析

* 时间复杂度：O(n)
* 空间复杂度：O(n)

### 代码

``` python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        if cost == None or len(cost) == 0:
            return 0
        dp = [0] * (len(cost) + 1)
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2, len(cost) + 1):
            dp[i] = min(dp[i - 1], dp[i - 2]) + (0 if i == len(cost) else cost[i])
        return dp[len(cost)]
```

